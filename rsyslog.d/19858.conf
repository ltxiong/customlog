
###############
#### RULES ####
###############

#  自动解析或存放(前置时间到秒)  
$template slog, "%$year%%$month%%$day%%$hour%%$minute%%TIMESTAMP:14:15% %msg:R,ERE,3,DFLT:(TESTLOG|APILOG|SERVICELOG)(_[a-zA-Z0-9]+)+\s(.*)--end%\n"
# 按照每分钟进行目录存放  
#$template slog_file_m, "/rsyslog/minute/%msg:R,ERE,1,DFLT:(TESTLOG|APILOG|SERVICELOG)(_[A-Z0-9]+)+\s.*--end:lowercase%/%msg:R,ERE,2,DFLT:(TESTLOG|APILOG|SERVICELOG)_([A-Z0-9]+)(_[a-zA-Z0-9]+)*\s.*--end:lowercase%/%msg:R,ERE,2,DFLT:(TESTLOG|APILOG|SERVICELOG)_([A-Z0-9]+(_[a-zA-Z0-9]+)*)\s.*--end:lowercase%/%$year%%$month%%$day%%$hour%%$minute%.log"
# 按照每天进行目录存放  
$template slog_file_d, "/rsyslog/day/%msg:R,ERE,1,DFLT:(TESTLOG|APILOG|SERVICELOG)(_[A-Z0-9]+)+\s.*--end:lowercase%/%msg:R,ERE,2,DFLT:(TESTLOG|APILOG|SERVICELOG)_([A-Z0-9]+)(_[a-zA-Z0-9]+)*\s.*--end:lowercase%/%msg:R,ERE,2,DFLT:(TESTLOG|APILOG|SERVICELOG)_([A-Z0-9]+(_[a-zA-Z0-9]+)*)\s.*--end:lowercase%/%$year%%$month%%$day%.log"
# 按照每秒钟进行目录存放  
#$template slog_file_s, "/rsyslog/seconds/%msg:R,ERE,1,DFLT:(TESTLOG|APILOG|SERVICELOG)(_[A-Z0-9]+)+\s.*--end:lowercase%/%msg:R,ERE,2,DFLT:(TESTLOG|APILOG|SERVICELOG)_([A-Z0-9]+)(_[a-zA-Z0-9]+)*\s.*--end:lowercase%/%msg:R,ERE,2,DFLT:(TESTLOG|APILOG|SERVICELOG)_([A-Z0-9]+(_[a-zA-Z0-9]+)*)\s.*--end:lowercase%/%$year%%$month%%$day%%$hour%%$minute%%TIMESTAMP:14:15%.log"
:msg, ereregex, "(TEST|API|SERVICE)LOG(_[A-Z0-9]+)+ " ?slog_file_d;slog
#:msg, ereregex, "(TEST|API|SERVICE)LOG(_[A-Z0-9]+)+ " ?slog_file_m;slog
#:msg, ereregex, "(TEST|API|SERVICE)LOG(_[A-Z0-9]+)+ " ?slog_file_s;slog
:msg, ereregex, "(TEST|API|SERVICE)LOG(_[A-Z0-9]+)+ " stop


# ### begin forwarding rule ###
# The statement between the begin ... end define a SINGLE forwarding
# rule. They belong together, do NOT split them. If you create multiple
# forwarding rules, duplicate the whole block!
# Remote Logging (we use TCP for reliable delivery)
#
# An on-disk queue is created for this action. If the remote host is
# down, messages are spooled  to disk and sent when it is up again.
#$WorkDirectory /var/lib/rsyslog # where to place spool files
#$ActionQueueFileName fwdRule1 # unique name prefix for spool files
#$ActionQueueMaxDiskSpace 1g   # 1gb space limit (use as much as possible)
#$ActionQueueSaveOnShutdown on # save messages to disk on shutdown
#$ActionQueueType LinkedList   # run asynchronously
#$ActionResumeRetryCount -1    # infinite retries if host is down
# remote host is: name/ip:port, e.g. 192.168.0.1:514, port optional
#*.* @@remote-host:514
# ### end of the forwarding rule ###

$WorkDirectory /rsyslog/workdir_log # where to place spool files
$ActionQueueFileName fwdRule1 # unique name prefix for spool files
#$ActionQueueMaxDiskSpace 1g   # 1gb space limit (use as much as possible)
$ActionQueueMaxDiskSpace 512m   # 1gb space limit (use as much as possible)
$ActionQueueSaveOnShutdown on # save messages to disk on shutdown
$ActionQueueType LinkedList   # run asynchronously
#$ActionResumeRetryCount -1    # infinite retries if host is down
# when to start discarding messages
$MainMsgQueueDiscardMark 20000

# limit of messages in the memory queue. When this is reached, it starts to write to disk
$MainMsgQueueHighWaterMark 20000

# memory queue size at which it stops writing to the disk
$MainMsgQueueLowWaterMark 20000

# maximum disk space used for the disk part of the queue
#$MainMsgQueueMaxDiskSpace 1g
$MainMsgQueueMaxDiskSpace 512m

# how many messages (messages, not bytes!) to hold in memory
$MainMsgQueueSize 20000

# don't throttle receiving messages when the queue gets full
$MainMsgQueueTimeoutEnqueue 0

# save the queue contents when stopping rsyslog
$MainMsgQueueSaveOnShutdown on
